import VisionRecallPlugin from '@/main';
import { Notice, Plugin, TFile } from 'obsidian';

// Generated by ChatGPT and not part of the rest of the functions below
export const findNotesWithTag = (plugin: VisionRecallPlugin, tag: string): string[] => {
  const filesWithTag: string[] = [];
  const cachedFiles = Object.keys(plugin.app.metadataCache.getCache('files') || {});
  cachedFiles.forEach((filePath) => {
    const metadata = plugin.app.metadataCache.getCache(filePath);

    if (metadata && metadata.tags) {
      const tags = metadata.tags.map(tagObj => tagObj.tag);
      if (tags.includes(tag)) {
        filesWithTag.push(filePath);
      }
    }
  });

  return filesWithTag;
}

export const findFirstNoteWithTag = async (plugin: Plugin, tag: string): Promise<string | null> => {
  const cachedFiles = Object.keys(plugin.app.metadataCache.getCache('files') || {});
  cachedFiles.forEach((filePath) => {
    const metadata = plugin.app.metadataCache.getCache(filePath);

    if (metadata && metadata.tags) {
      const tags = metadata.tags.map(tagObj => tagObj.tag);
      if (tags.includes(tag)) {
        return filePath;
      }
    }
  });

  return null;
}

export const findNotesWithTagInline = async (plugin: VisionRecallPlugin, tag: string): Promise<string[]> => {
  const matchingFiles: string[] = [];

  for (const file of plugin.app.vault.getMarkdownFiles()) {
    const content = await plugin.app.vault.read(file);
    if (content.includes(tag)) {
      matchingFiles.push(file.path);
    }
  }

  return matchingFiles;
}

export const openNoteWithTagOld = async (plugin: VisionRecallPlugin, tag: string): Promise<void> => {
  const file = await findFirstNoteWithTag(plugin, tag);
  if (file) {
    await plugin.app.workspace.openLinkText(file, '', false, { active: true });
  } else {
    plugin.logger.info(`No notes found with tag ${tag}`);
  }

  // const files = findNotesWithTag(plugin, tag);
  // if (files.length > 0) {
  //   const file = plugin.app.vault.getAbstractFileByPath(files[0]);
  //   if (file instanceof TFile) {
  //     // plugin.app.workspace.getMostRecentLeaf().openFile(file); // might want to open in a new tab instead
  //     await plugin.app.workspace.openLinkText(file.path, '', false, { active: true });
  //   }
  // } else {
  //   console.log(`No notes found with tag ${tag}`);
  // }
}


// --- Helper Functions for Note Linking by Full Unique Tag (Using metadataCache) ---

export async function getNoteByUniqueTagOrCreateTag(plugin: VisionRecallPlugin, noteName: string, parentTagPrefix: string): Promise<TFile | null> {
  const { vault, metadataCache, workspace } = plugin.app;
  let targetFile = vault.getAbstractFileByPath(`${noteName}.md`) as TFile;

  if (!targetFile) {
    // If not found by name, try to find by unique nested tag using metadataCache
    // We need to generate the unique tag first to search for it
    const uniqueId = generateUniqueId();
    const fullUniqueTag = `#${parentTagPrefix}/${uniqueId}`;
    targetFile = await findNoteByUniqueTag(plugin, fullUniqueTag); // Pass the full unique tag
    if (targetFile) {
      return targetFile;
    } else {
      return null;
    }
  }

  // File found by name (or was just created if you have note creation logic elsewhere)
  const uniqueTag = await ensureUniqueTagExists(plugin, targetFile, parentTagPrefix);
  if (!uniqueTag) {
    plugin.logger.error("Failed to ensure unique tag exists for file:", targetFile.path);
    return null;
  }
  return targetFile;
}


export async function findNoteByUniqueTag(plugin: VisionRecallPlugin, fullUniqueTag: string): Promise<TFile | null> { // Now accepts fullUniqueTag
  const { vault, metadataCache } = plugin.app;
  const allFiles = vault.getMarkdownFiles();

  for (const file of allFiles) {
    const metadata = metadataCache.getFileCache(file); // Get cached metadata for the file
    if (metadata && metadata.tags) { // Check if metadata and tags exist
      const tags = metadata.tags;
      for (const tagCache of tags) { // Iterate through the tags in the cache
        if (tagCache.tag === fullUniqueTag) { // Check for exact match with fullUniqueTag
          return file; // Found a file with the exact unique tag
        }
      }
    }
  }
  return null; // No note found with the exact unique tag
}


export async function ensureUniqueTagExists(plugin: VisionRecallPlugin, file: TFile, parentTagPrefix: string): Promise<string | null> {
  const { vault } = plugin.app;
  let fileContent = await vault.read(file);
  const existingTag = await findUniqueTagInContent(fileContent, parentTagPrefix);

  if (existingTag) {
    return existingTag;
  } else {
    // Generate a new unique tag - now with nested structure #parent/child
    const newUniqueId = generateUniqueId();
    const newUniqueTag = `#${parentTagPrefix}/${newUniqueId}`; // Construct nested tag

    // Append the new tag to the end of the file content
    const updatedContent = fileContent.trimEnd() + `\n\n${newUniqueTag}`;
    await vault.modify(file, updatedContent);
    return newUniqueTag;
  }
}

export async function findUniqueTagInContent(content: string, parentTagPrefix: string): Promise<string | null> {
  const tagRegex = new RegExp(`#${parentTagPrefix}/([a-zA-Z0-9-]+)`, 'g');
  const matches = content.matchAll(tagRegex);
  for (const match of matches) {
    if (match && match[0]) {
      return match[0];
    }
  }
  return null;
}


export function generateUniqueId(): string {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

export const searchForFirstNoteWithContent = async (plugin: VisionRecallPlugin, tag: string): Promise<string | null> => {
  const files = plugin.app.vault.getMarkdownFiles();
  for (const file of files) {
    const content = await plugin.app.vault.cachedRead(file);
    if (content.includes(tag)) {
      return file.path;
    }
  }
  return null;
}

export const openNoteWithContent = async (plugin: VisionRecallPlugin, content: string): Promise<void> => {
  plugin.logger.info(`openNoteWithContent: content: ${content}`);
  const file = await searchForFirstNoteWithContent(plugin, content);
  if (file) {
    await plugin.app.workspace.openLinkText(file, '', false, { active: true });
  } else {
    plugin.logger.info(`No notes found with content ${content}`);
  }
}


export const openNoteWithTag = async (plugin: VisionRecallPlugin, tag: string): Promise<void> => {
  plugin.logger.info(`openNoteWithTag: tag: ${tag}`);
  // const searchContent = `#${plugin.settings.tagPrefix}/${tag}`;
  let searchContent = tag;
  if (!tag.includes('#')) {
    searchContent = `#${plugin.settings.tagPrefix}/${tag}`;
  }
  const file = await searchForFirstNoteWithContent(plugin, searchContent);
  if (file) {
    await plugin.app.workspace.openLinkText(file, '', false, { active: true });
  } else {
    plugin.logger.info(`No notes found with tag ${tag}`);
    new Notice(`Could not find note with identifying tag: ${searchContent}`);
  }
}

export const findNoteByTag = async (plugin: VisionRecallPlugin, tag: string): Promise<TFile | null> => {
  plugin.logger.info(`findNoteByTag: tag: ${tag}`);
  // const searchContent = `#${plugin.settings.tagPrefix}/${tag}`;
  let searchContent = tag;
  if (!tag.includes('#')) {
    searchContent = `#${plugin.settings.tagPrefix}/${tag}`;
  }
  const file = await searchForFirstNoteWithContent(plugin, searchContent);
  if (file) {
    return plugin.app.vault.getAbstractFileByPath(file) as TFile;
  }
  return null;
}